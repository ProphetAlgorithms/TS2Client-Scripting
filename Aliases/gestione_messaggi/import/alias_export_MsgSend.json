{
  "class": "StrMsg",
  "enabled": true,
  "id": "MsgSend",
  "is_prompt": false,
  "is_script": true,
  "pattern": "^\\s*(emo|gossip|gt|gui|herogoss|mess|ot|say|send|shout|si|tele|tell|whi)(?=\\s|$)\\s?(\\s*[^\\s]+\\s?)?(.+)?",
  "regex": true,
  "value": "let headParam = $2;\nlet tailParams = $3;\nlet fullParams = $2 + $3;\nlet sendSilent = true;\n//Divido i parametri in un array\n//let arrParams = params.trim().split(/\\s+/);\n//Se non ci sono parametri, split restituisce una stringa vuota e in questo caso setto params come\n//vettore vuoto per poterne controllare la lunghezza\n//if (arrParams == \"\") {arrParams = [];}\n//Controllo se esiste la lista dei comandi.\nif (typeof MsgData == 'undefined') {\n      this.MsgData = {};\n      MsgData.menuMgmt = {};\n      MsgData.menuMgmt[\"cmds\"] = [\"color\",\"default\",\"string\",\"list\",\"mode\",\"status\"];\n}\n//Controllo se ci sono parametri\nif (headParam.trim() != \"\") {\n   //** Ci sono parametri\n   //Controllo se le variabili necessarie esistono;\n   //cmd è usato per calcolare i caratteri disponibili nel buffer e per indicare all'alias che \n   //gestisce i comandi il tipo di messaggio di riferimento\n   let cmd = match[1];\n   if (typeof MsgData.colorMgmt == 'undefined') {\n      MsgData.colorMgmt = {};\n      MsgData.colorMgmt[\"cmdDefault\"] = {\n                                          \"emo\": [\"0015\",\"emote\",1],\n                                          \"gossip\": [\"0011\",\"gossip\",1],\n                                          \"gt\": [\"0012\",\"gt\",1],\n                                          \"gui\": [\"0014\",\"gui\",1],\n                                          \"herogoss\": [\"0011\",\"herogoss\",1],\n                                          \"mess\": [\"0013\",\"messenger\",0],\n                                          \"ot\": [\"0002\",\"ot\",1],\n                                          \"say\": [\"0015\",\"say\",1],\n                                          \"send\": [\"0013\",\"send\",0],\n                                          \"shout\": [\"0009\",\"shout\",1],\n                                          \"si\": [\"0002\",\"sign\",1],\n                                          \"tele\": [\"0013\",\"telepathy\",0],\n                                          \"tell\": [\"0013\",\"tell\",0],\n                                          \"whi\": [\"0005\",\"whisper\",0]\n                                        };\n      MsgData.colorMgmt[\"cliEffects\"] = [\"nofx\",\"high\",\"under\",\"blink\",\"reverse\"];\n      MsgData.colorMgmt[\"mudEffects\"] = [\"0\",\"1\",\"4\",\"5\",\"6\"];\n      MsgData.colorMgmt[\"cliBgr\"] = [\"#000\",\"#bb0000\",\"#00bb00\",\"#bbbb00\",\"#1616e2\",\"#bb00bb\",\"#00bbbb\",\"#c0c0c0\"];\n      MsgData.colorMgmt[\"mudBgr\"] = [\"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\"];\n      MsgData.colorMgmt[\"cliColor\"] = [\"#000\",\"#bb0000\",\"#00bb00\",\"#bbbb00\",\"#1616e2\",\"#bb00bb\",\"#00bbbb\",\"#c0c0c0\",\"#808080\",\"#ff0000\",\"#00ff00\",\"#ffff00\",\"#6464ff\",\"#ff00ff\",\"#00ffff\",\"#ffffff\"];\n      MsgData.colorMgmt[\"cliHighColor\"] = [\"#808080\",\"#ff0000\",\"#00ff00\",\"#ffff00\",\"#6464ff\",\"#ff00ff\",\"#00ffff\",\"#ffffff\",\"#808080\",\"#ff0000\",\"#00ff00\",\"#ffff00\",\"#6464ff\",\"#ff00ff\",\"#00ffff\",\"#ffffff\"];\n      MsgData.colorMgmt[\"mudColor\"] = [\"00\",\"01\",\"02\",\"03\",\"04\",\"05\",\"06\",\"07\",\"08\",\"09\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\"];\n      MsgData.colorMgmt[\"cmdBgr\"] = [\"bg-nero\",\"bg-rosso\",\"bg-verde\",\"bg-marrone\",\"bg-blu\",\"bg-magenta\",\"bg-ciano\",\"bg-grigio\"];\n      MsgData.colorMgmt[\"cmdColor\"] = [\"nero\",\"rosso-scuro\",\"verde-scuro\",\"marrone\",\"blu-scuro\",\"magenta-scuro\",\"azzurro-ciano-scuro\",\"grigio-chiaro\",\"grigio-scuro\",\"rosso-chiaro\",\"verde-chiaro\",\"giallo\",\"blu-chiaro\",\"magenta-chiaro\",\"azzurro-ciano-chiaro\",\"bianco\"];\n   }\n   if (typeof MsgData[cmd] == 'undefined') {\n      MsgData[cmd] = {};\n      MsgData[cmd][\"defColor\"] = MsgData.colorMgmt.cmdDefault[cmd][0];\n      //Lista dei colori per la modalità \"rand\" e \"seq\"\n      MsgData[cmd][\"listMudColor\"] = [];\n      MsgData[cmd][\"mode\"] = \"def\";\n      MsgData[cmd][\"startString\"] = [];\n      MsgData[cmd][\"endString\"] = [];\n      MsgData[cmd][\"activeString\"] = 0;\n      MsgData[cmd][\"activeDefMudColor\"] = 0;\n      //Lista dei colori per la modalità \"def\"\n      MsgData[cmd][\"listDefMudColor\"] = [];\n      MsgData[cmd][\"listsMudColor\"] = [];\n   }\n   if (typeof MsgData.menuMgmt[\"dataColor\"] == 'undefined') {\n      MsgData.menuMgmt[\"dataColor\"] = \"azzurro-ciano-scuro\";\n      MsgData.menuMgmt[\"menuColor\"] = \"magenta-scuro\";\n      MsgData.menuMgmt[\"infoColor\"] = \"azzurro-ciano-scuro\";\n      MsgData.menuMgmt[\"borderColor\"] = \"magenta-scuro\";\n   }\n   if (typeof MsgData.strMgmt == 'undefined') {\n      MsgData.strMgmt = {};\n      MsgData.strMgmt[\"maxChar\"] = 510;\n   } \n   //Controllo se il primo parametro fa parte dei comandi selezionabili\n   if (MsgData.menuMgmt[\"cmds\"].includes(headParam.trim())) {\n     //** Il primo parametro è un comando\n     send(\"msgmgmt \" + cmd + \" \" + fullParams);\n   } else {\n     //** Il primo parametro non è un comando\n     //Funzione che aggiungere i colori al messaggio.\n     //Insieme al colore viene anteposto un codice nullo $c0000 per resettare gli effetti di codici precedenti\n     //che altrimenti resterebbero attivi anche ai codici successivi con effetti attivi.\n     function addColor(cmd,str) {\n        //Variabile che conterrà il messaggio\n        let msg = \"\";\n        switch (MsgData[cmd][\"mode\"]) {\n           case \"def\":\n             //Controllo che il colore scelto non sia quello di base ed esista nella lista e lo \n             //aggiungo dopo ogni spazio\n             if (MsgData[cmd][\"activeDefMudColor\"] > 0 && MsgData[cmd][\"listDefMudColor\"].length >= MsgData[cmd][\"activeDefMudColor\"]) {\n               //Colore non di default e presente in lista, aggiungo il colore\n               msg = str.replace(/\\s+/gm, function(match) {\n                                                return match + \"$c\" + MsgData[cmd][\"listDefMudColor\"][MsgData[cmd][\"activeDefMudColor\"] - 1];\n                                             });\n               //Aggiungo il colore all'inizio del messaggio per preservare gli spazi iniziali che andrebbero\n               //persi con la funzione send\n               msg = \"$c0000$c\" + MsgData[cmd][\"listDefMudColor\"][MsgData[cmd][\"activeDefMudColor\"] - 1] + msg;\n               return msg;\n             } else {\n               //Colore di base selezionato, aggiungo il colore\n               msg = str.replace(/\\s+/gm, function(match) {\n                                                return match + \"$c\" + MsgData[cmd][\"defColor\"];\n                                             });\n               //Aggiungo il colore all'inizio del messaggio per preservare gli spazi iniziali che andrebbero\n               //persi con la funzione send\n               msg = \"$c0000$c\" + MsgData[cmd][\"defColor\"] + msg;\n               return msg;\n             }\n             break;\n           case \"rand\":\n             //Controllo che la lista abbia elementi e aggiungo un colore casuale dopo ogni spazio\n             if (MsgData[cmd][\"listMudColor\"].length > 0) {\n               //La lista contiene elementi. aggiungo un colore casuale\n               msg = str.replace(/\\s+/gm, function(match) {\n                                                return match + \"$c0000$c\" + MsgData[cmd][\"listMudColor\"][Math.floor(Math.random() * MsgData[cmd][\"listMudColor\"].length)];\n                                             });\n               //Aggiungo il colore all'inizio del messaggio per preservare gli spazi iniziali che andrebbero\n               //persi con la funzione send\n               msg = \"$c0000$c\" + MsgData[cmd][\"listMudColor\"][Math.floor(Math.random() * MsgData[cmd][\"listMudColor\"].length)] + msg;\n               return msg;\n             } else {\n               //La lista è vuota, aggiungo il colore base\n               msg = str.replace(/\\s+/gm, function(match) {\n                                                return match + \"$c\" + MsgData[cmd][\"defColor\"];\n                                             });\n               //Aggiungo il colore all'inizio del messaggio per preservare gli spazi iniziali che andrebbero\n               //persi con la funzione send\n               msg = \"$c0000$c\" + MsgData[cmd][\"defColor\"] + msg;\n               return msg;\n             }\n             break;\n           case \"seq\":\n             //Controllo che la lista abbia elementi e aggiungo i colori\n             if (MsgData[cmd][\"listMudColor\"].length > 0) {\n               //La lista contiene elementi, aggiungo i colori sequenzialmente\n               let colorIndex = 0;\n               let offset = 0;\n               //Se la stringa non inizia con uno spazio inizializzo indice con il secondo colore, se c'è, ed\n               //il primo colore verrà assegnato al codice aggiunto ad ogni inizio match\n               if (!str.startsWith(' ') && MsgData[cmd][\"listMudColor\"].length > 1) {\n                  colorIndex = 1;\n                  offset = 1;\n               }\n               //Lindice viene aumentato o diminuito con un offset che cambia con il primo e l'ultimo elemento del vettore\n               msg = str.replace(/\\s+/gm, function(match) {\n                                                let res = match + \"$c0000$c\" + MsgData[cmd][\"listMudColor\"][colorIndex];\n                                                if (colorIndex == 0 && MsgData[cmd][\"listMudColor\"].length > 1) {offset = 1}\n                                                if (colorIndex == MsgData[cmd][\"listMudColor\"].length - 1 && MsgData[cmd][\"listMudColor\"].length > 1) {offset = -1}\n                                                colorIndex = colorIndex + offset;\n                                                return res;\n                                             })\n               //Aggiungo il colore all'inizio del messaggio per preservare gli spazi iniziali che andrebbero\n               //persi con la funzione send\n               msg = \"$c0000$c\" + MsgData[cmd][\"listMudColor\"][0] + msg;\n               return msg;\n             } else {\n               //La lista è vuota, aggiungo il colore base\n               msg = str.replace(/\\s+/gm, function(match) {\n                                                return match + \"$c\" + MsgData[cmd][\"defColor\"];\n                                             })\n               //Aggiungo il colore all'inizio del messaggio per preservare gli spazi iniziali che andrebbero\n               //persi con la funzione send\n               msg = \"$c0000$c\" + MsgData[cmd][\"defColor\"] + msg;\n               return msg;\n             }                                 \n             break;\n           default:\n              msg = str.replace(/\\s+/gm, function(match) {\n                                                return match + \"$c\" + MsgData[cmd][\"defColor\"];\n                                             })\n               //Aggiungo il colore all'inizio del messaggio per preservare gli spazi iniziali che andrebbero\n               //persi con la funzione send\n               msg = \"$c0000$c\" + MsgData[cmd][\"defColor\"] + msg;\n               return msg;\n         }\n         \n     }//Fine funzione addColor()\n     //Funzione che assembla il messaggio finale e lo invia\n     function sendMsg(cmd, headParam,tailParams) {\n        //Variabile che indica se il comando ha un target o meno\n        let noTarget = 0;\n        let freeChar = MsgData.strMgmt[\"maxChar\"];\n        let sStr = \"\";\n        let eStr = \"\";\n        //Controllo se il comando ha un target o meno e setto la relativa variabile, nel caso avesse un target\n        //diminuisco i caratteri disponibili perché il mud, per il comando \"messenger\" che ha un target,\n        //tronca il messaggio a 510 caratteri ma nella stringa del messaggio inviato al target e al mittente\n        //risultano dimensioni diverse. Ho diminuito i caratteri disponibii finché non ho riscontrato\n        //più errori.\n        if (MsgData.colorMgmt.cmdDefault[cmd][2] == 1) {noTarget = 1} {freeChar = freeChar - 70}\n        //Sottraggo la quantità di caratteri, dal totale disponibile, della stringa aggiuntiva iniziale e finale\n        //perché sono caratteri aggiunti dopo la regex\n        //Controllo se c'è una stringa attiva e se è presente in lista\n        if (MsgData[cmd][\"activeString\"] > 0 && MsgData[cmd][\"startString\"].length >= MsgData[cmd][\"activeString\"]) {\n          //Assegno entrambe le stringhe a due variabili da usare nell'assemblamento della stringa finale\n          if (MsgData[cmd][\"startString\"][MsgData[cmd][\"activeString\"] - 1] != \"nostring\") {\n            sStr = MsgData[cmd][\"startString\"][MsgData[cmd][\"activeString\"] - 1] + \" \"; \n          } else {\n            sStr = \"\";\n          }\n          if (MsgData[cmd][\"endString\"][MsgData[cmd][\"activeString\"] - 1] != \"nostring\") {\n            eStr = \" \" + MsgData[cmd][\"endString\"][MsgData[cmd][\"activeString\"] - 1];\n          } else {\n            eStr = \"\";\n          }\n          //Controllo se c'è il carattere $ e la sua quantità perché il mud lo duplica e conta per due caratteri\n          freeChar = freeChar - ((sStr + eStr).match(/\\$/gm)||[]).length;\n          //Controllo la lunghezza della stringa iniziale e finale e la sottraggo al totale\n          freeChar = freeChar - (sStr + eStr).length;\n        }\n        //Sottraggo dai caratteri disponibili i caratteri del comando con lo spazio, il codice colore \n        //iniziale e finale e il possibile carattere dollaro diviso su più stringhe\n        freeChar = freeChar - (28 + MsgData.colorMgmt.cmdDefault[cmd][1].length + 1 + 1);\n        if (freeChar > 0) {\n          let target = \"\";\n          let colMsg = \"\";\n          //Controllo se il comando ha un target o meno ed in caso lo separo dal messaggio\n          if (noTarget == 1) {\n            colMsg = addColor(cmd, fullParams);\n          } else {\n            target = headParam.trim() + \" \";\n            colMsg = addColor(cmd, tailParams);\n            freeChar = freeChar - target.length;\n          }\n          //Regex per dividere il messaggio in base allo spazio disponibile\n          //La regex cerca di prendere più caratteri possibili evitando di catturare parti di codice colore ma\n          //solo parole intere con codice colore intero. Se i caratteri disponibili non sono sufficienti a catturare il\n          //codice colore più una parola intera con lo spazio adiacente, o più volte questa sequenza, verrà catturata\n          //parte della parola finché non viene acquisita tutta, divisa su più messaggi.\n          let splitBuffRegex = new RegExp(\"((?<=^|\\\\s)(?:(?:\\\\$\\\\$c0000)?\\\\$\\\\$c\\\\d\\\\d\\\\d\\\\d))?((?:.{1,\" + freeChar + \"}(?:(?<=\\\\s)(?!\\\\s)|$))|.{1,\" + freeChar + \"})?\", \"gm\");\n          //Duplico il carattere $ considerato doppio per il mud in modo da avere un conteggio preciso nella regex\n          colMsg = colMsg.replace(/\\$/gm, \"$$$$\");\n          //Elimino il codice colore alla fine della stringa\n          colMsg = colMsg.replace(/\\s\\$\\$c\\d\\d\\d\\d$/gm, \" \");\n          //Controllo che la stringa rispetti la dimensione massima del buffer, in caso contrario la divido in più parti e\n          //il risultato lo inserisco in un vettore contenente i gruppi di acquisizione\n          let arrMsg = [...colMsg.matchAll(splitBuffRegex)];\n          //Variabile usata per indicare quale simbolo $ tenere o cancellare se diviso su più stringhe\n          let rmDollar = 0;\n          //Variabile usata per contenere il codice colore iniziale dopo avere sostituito il doppio $\n          let startColor = \"\";\n          //Variabile usata per contenere il corpo del messaggio preso dalla regex\n          let bodyMsg = \"\";\n          //Ciclo che controlla tutti i match della regex e assembla il messaggio finale\n          for (const regexGroups of arrMsg) {\n            //Catturo il codice colore iniziale e sostituisco il doppio $ con un solo $\n            if (regexGroups[1] != undefined) {\n              //Se manca un codice nullo $c0000 all'inizio di un match, lo aggiungo\n              let resetColor = \"\";\n              if (/^\\$\\$c\\d\\d\\d\\d$/gm.test(regexGroups[1])) {resetColor = \"$c0000\"}\n              startColor = resetColor + regexGroups[1].replace(/\\$\\$/gm, \"$$\")\n            }\n            //Trovo il gruppo con il messaggio e sostituisco il doppio $ con un solo $, e riporto il messaggio allo\n            //stato originale. Considerando che il doppio $ in origine è solo un $ nella regex una coppia può essere\n            //divisa in due match e per questo un $ viene lasciato e l'altro viene eliminato in modo da avere un solo\n            //carattere $, come dovrebbe essere.\n            if (regexGroups[2] != undefined) {\n              bodyMsg = regexGroups[2].replace(/\\$\\$|\\$/gm, function(match) {\n                                                               switch (match) {\n                                                                 case \"$$\":\n                                                                   return \"$\";\n                                                                   break;\n                                                                 case \"$\":\n                                                                   if (rmDollar == 0) {\n                                                                     rmDollar = 1;\n                                                                     return \"$\";\n                                                                   } else {\n                                                                     rmDollar = 0;\n                                                                     return \"\";\n                                                                   }\n                                                                   break;\n                                                               }\n                                                            })\n              if (bodyMsg != \"\") {\n                send(\"~\" + MsgData.colorMgmt.cmdDefault[cmd][1] + \" \" + target + sStr + startColor + bodyMsg + eStr + \"$c0000$c\" + MsgData[cmd][\"defColor\"], sendSilent);\n              }\n            }\n          }//Fine del for\n        } else {\n          print(\"Spazio disponibile per inserire il messaggio < 1\" + \"\\n\");\n        }//Se freeChar > 0\n     }//Fine della funzione sendMsg \n     sendMsg(cmd, headParam, tailParams);\n   }//Fine della sezione in cui si trova il messaggio da inviare\n} else {\n  //** Non ci sono parametri\n  print(color(\"\\nComandi disponibili: \",\"#bb00bb\") + color(MsgData.menuMgmt[\"cmds\"],\"#00ffff\") + \"\\n\");\n}",
  "shortcut": ""
}
